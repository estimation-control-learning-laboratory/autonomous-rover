volatile long encoder_pulse = 0;
unsigned long prevMillis = 0;
const long interval = 1000;  // time interval
const int Num_motors = 4;
float RPM[Num_motors];
float distance[Num_motors] ;
long Last_Measured_Pulses[Num_motors] ;
long currentPulse[Num_motors];;

// Hardware Constants
const int ENCODER_PPR = 12;  // Encoder pulses per 360 degrees
const int Shaft_Gear_Ratio = 120;
const int wheel_Radius = 48;  // mm

// Encoder Channel Pins
// const int encoderchannelA[Num_motors] = { 2, 4, 6, 8 }; // Motor A pins
// const int encoderchannelB[Num_motors] = { 3, 5, 7, 9 }; // Motor B pins
const int encoderchannelA[Num_motors] = {22, 27, 3, 4};  //encoder pin A, must be interrupt capable
const int encoderchannelB[Num_motors] = {23, 26, 2, 5};  //encoder pin B, must be interrupt capablea

// Store the number of pulses per time interval
volatile long encoder_pulses[Num_motors];

// These Funtions Record the Encoder pulses as we as the direction based on channel A&B
void readEncoderA(int encoderIndex) {
  // CASE1: Pin A
  // If A = HIGH check B
  if (digitalRead(encoderchannelA[encoderIndex]) == HIGH) {
    if (digitalRead(encoderchannelB[encoderIndex]) == LOW) {
      encoder_pulses[encoderIndex]++;
    } else {
      encoder_pulses[encoderIndex]--;
    }
  }
  // If A = LOW check B
  else {
    if (digitalRead(encoderchannelB[encoderIndex]) == HIGH) {
      encoder_pulses[encoderIndex]++;
    } else {
      encoder_pulses[encoderIndex]--;
    }
  }
}

void readEncoderB(int encoderIndex) {
  // CASE 2: Pin B
  if (digitalRead(encoderchannelB[encoderIndex]) == HIGH) {
    if (digitalRead(encoderchannelA[encoderIndex]) == HIGH) {
      encoder_pulses[encoderIndex]++;
    } else {
      encoder_pulses[encoderIndex]--;
    }
  } else {
    if (digitalRead(encoderchannelA[encoderIndex]) == LOW) {
      encoder_pulses[encoderIndex]++;
    } else {
      encoder_pulses[encoderIndex]--;
    }
  }
}
void setup() {
  Serial.begin(115200);

  for (int i = 0; i < Num_motors; i++) {
    pinMode(encoderchannelA[i], INPUT_PULLUP);
    pinMode(encoderchannelB[i], INPUT_PULLUP);
    switch (i) {
      case 0:
        attachInterrupt(digitalPinToInterrupt(encoderchannelA[i]), callInterruptA0, RISING);  // Funtion that checks for pulses
        attachInterrupt(digitalPinToInterrupt(encoderchannelB[i]), callInterruptB0, RISING);  // Funtion that checks for pulses
        break;
      case 1:
        attachInterrupt(digitalPinToInterrupt(encoderchannelA[i]), callInterruptA1, RISING);  // Funtion that checks for pulses
        attachInterrupt(digitalPinToInterrupt(encoderchannelB[i]), callInterruptB1, RISING);  // Funtion that checks for pulses
        break;
      case 2:
        attachInterrupt(digitalPinToInterrupt(encoderchannelA[i]), callInterruptA2, RISING);  // Funtion that checks for pulses
        attachInterrupt(digitalPinToInterrupt(encoderchannelB[i]), callInterruptB2, RISING);  // Funtion that checks for pulses
        break;

      case 3:
        attachInterrupt(digitalPinToInterrupt(encoderchannelA[i]), callInterruptA3, RISING);  // Funtion that checks for pulses
        attachInterrupt(digitalPinToInterrupt(encoderchannelB[i]), callInterruptB3, RISING);  // Funtion that checks for pulses
        break;
    }
  }
}

void loop() {

  if ((millis() - prevMillis) >= interval) {
    prevMillis = millis();
    calculations();
    displayingData();
  }
}

void calculations() {

  long currentPulses[Num_motors];

  noInterrupts();
  for (int i = 0; i < Num_motors; i++) {
    currentPulses[i] = encoder_pulses[i];
  }
  interrupts();
  for (int i = 0; i < Num_motors; i++) {
    long interval_pulses = currentPulses[i] - Last_Measured_Pulses[i];  
                                                    // calculate pulses over the interval
    float revolutions = (float)interval_pulses / (ENCODER_PPR * Shaft_Gear_Ratio);
    float rpm_float = (revolutions / interval) * 60000.0; // (rev/ms) * (60000 ms/min)
    RPM[i] = rpm_float;

    // Calculate total distance traveled in meters
    float totalRevolutions = (float)currentPulses[i] / (ENCODER_PPR * Shaft_Gear_Ratio);
    float distance_mm = totalRevolutions * wheel_Radius*2*PI;
    distance[i] = distance_mm / 1000.0; // Convert to meters
    Last_Measured_Pulses[i] = currentPulses[i];             // update Last_Measured_Pulses with cuurrentPulse
  }
}

void displayingData() {
  Serial.println("----------------------------------------------------------");
  Serial.println("Motor\t|  Total Pulses\t|  RPM\t\t|  Distance (m)");
  Serial.println("----------------------------------------------------------");

  char buffer[80];

  for (int i = 0; i < Num_motors; i++) {
    sprintf(buffer, "  %d\t|  %-12ld\t|  %-7.2f\t|  %.3f",
            i,
            Last_Measured_Pulses[i],
            RPM[i],
            distance[i]);
    Serial.println(buffer);
  }
  Serial.println();
}

// Functions to call the main Global Interruptor Functions
void callInterruptA0() {
  readEncoderA(0);
}
void callInterruptB0() {
  readEncoderB(0);
}

void callInterruptA1() {
  readEncoderA(1);
}
void callInterruptB1() {
  readEncoderB(1);
}

void callInterruptA2() {
  readEncoderA(2);
}
void callInterruptB2() {
  readEncoderB(2);
}

void callInterruptA3() {
  readEncoderA(3);
}
void callInterruptB3() {
  readEncoderB(3);
}
